{"ast":null,"code":"import { key2pos } from './util.js';\nexport { createElement, setAttributes };\nexport function createDefs() {\n  const defs = createElement('defs');\n  const filter = setAttributes(createElement('filter'), {\n    id: 'cg-filter-blur'\n  });\n  filter.appendChild(setAttributes(createElement('feGaussianBlur'), {\n    stdDeviation: '0.022'\n  }));\n  defs.appendChild(filter);\n  return defs;\n}\nexport function renderSvg(state, shapesEl, customsEl) {\n  var _a;\n  const d = state.drawable,\n    curD = d.current,\n    cur = curD && curD.mouseSq ? curD : undefined,\n    dests = new Map(),\n    bounds = state.dom.bounds(),\n    nonPieceAutoShapes = d.autoShapes.filter(autoShape => !autoShape.piece);\n  for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [cur] : [])) {\n    if (!s.dest) continue;\n    const sources = (_a = dests.get(s.dest)) !== null && _a !== void 0 ? _a : new Set(),\n      from = pos2user(orient(key2pos(s.orig), state.orientation), bounds),\n      to = pos2user(orient(key2pos(s.dest), state.orientation), bounds);\n    sources.add(moveAngle(from, to));\n    dests.set(s.dest, sources);\n  }\n  const shapes = d.shapes.concat(nonPieceAutoShapes).map(s => {\n    return {\n      shape: s,\n      current: false,\n      hash: shapeHash(s, isShort(s.dest, dests), false, bounds)\n    };\n  });\n  if (cur) shapes.push({\n    shape: cur,\n    current: true,\n    hash: shapeHash(cur, isShort(cur.dest, dests), true, bounds)\n  });\n  const fullHash = shapes.map(sc => sc.hash).join(';');\n  if (fullHash === state.drawable.prevSvgHash) return;\n  state.drawable.prevSvgHash = fullHash;\n  /*\n    -- DOM hierarchy --\n    <svg class=\"cg-shapes\">      (<= svg)\n      <defs>\n        ...(for brushes)...\n      </defs>\n      <g>\n        ...(for arrows and circles)...\n      </g>\n    </svg>\n    <svg class=\"cg-custom-svgs\"> (<= customSvg)\n      <g>\n        ...(for custom svgs)...\n      </g>\n    </svg>\n  */\n  const defsEl = shapesEl.querySelector('defs');\n  syncDefs(d, shapes, defsEl);\n  syncShapes(shapes, shapesEl.querySelector('g'), customsEl.querySelector('g'), s => renderShape(state, s, d.brushes, dests, bounds));\n}\n// append only. Don't try to update/remove.\nfunction syncDefs(d, shapes, defsEl) {\n  var _a;\n  const brushes = new Map();\n  let brush;\n  for (const s of shapes) {\n    if (s.shape.dest) {\n      brush = makeCustomBrush(d.brushes[s.shape.brush], s.shape.modifiers);\n      if ((_a = s.shape.modifiers) === null || _a === void 0 ? void 0 : _a.hilite) brushes.set('hilite', d.brushes['hilite']);\n      brushes.set(brush.key, brush);\n    }\n  }\n  const keysInDom = new Set();\n  let el = defsEl.firstElementChild;\n  while (el) {\n    keysInDom.add(el.getAttribute('cgKey'));\n    el = el.nextElementSibling;\n  }\n  for (const [key, brush] of brushes.entries()) {\n    if (!keysInDom.has(key)) defsEl.appendChild(renderMarker(brush));\n  }\n}\nfunction syncShapes(syncables, shapes, customs, renderShape) {\n  const hashesInDom = new Map();\n  for (const sc of syncables) hashesInDom.set(sc.hash, false);\n  for (const root of [shapes, customs]) {\n    const toRemove = [];\n    let el = root.firstElementChild,\n      elHash;\n    while (el) {\n      elHash = el.getAttribute('cgHash');\n      if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);else toRemove.push(el);\n      el = el.nextElementSibling;\n    }\n    for (const el of toRemove) root.removeChild(el);\n  }\n  // insert shapes that are not yet in dom\n  for (const sc of syncables.filter(s => !hashesInDom.get(s.hash))) {\n    for (const svg of renderShape(sc)) {\n      if (svg.isCustom) customs.appendChild(svg.el);else shapes.appendChild(svg.el);\n    }\n  }\n}\nfunction shapeHash({\n  orig,\n  dest,\n  brush,\n  piece,\n  modifiers,\n  customSvg,\n  label\n}, shorten, current, bounds) {\n  // a shape and an overlay svg share a lifetime and have the same cgHash attribute\n  return [bounds.width, bounds.height, current, orig, dest, brush, shorten && '-', piece && pieceHash(piece), modifiers && modifiersHash(modifiers), customSvg && `custom-${textHash(customSvg)}`, label && `label-${textHash(label.text)}`].filter(x => x).join(',');\n}\nfunction pieceHash(piece) {\n  return [piece.color, piece.role, piece.scale].filter(x => x).join(',');\n}\nfunction modifiersHash(m) {\n  var _a;\n  return [m.lineWidth, m.hilite && '*', (_a = m.overlayCustomSvg) === null || _a === void 0 ? void 0 : _a[0]].filter(x => x).join(',');\n}\nfunction textHash(s) {\n  // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n  let h = 0;\n  for (let i = 0; i < s.length; i++) {\n    h = (h << 5) - h + s.charCodeAt(i) >>> 0;\n  }\n  return h.toString();\n}\nfunction renderShape(state, {\n  shape,\n  current,\n  hash\n}, brushes, dests, bounds) {\n  var _a, _b, _c;\n  const from = pos2user(orient(key2pos(shape.orig), state.orientation), bounds),\n    to = shape.dest ? pos2user(orient(key2pos(shape.dest), state.orientation), bounds) : from,\n    brush = makeCustomBrush(brushes[shape.brush], shape.modifiers),\n    slots = dests.get(shape.dest),\n    svgs = [];\n  if (!shape.customSvg || ((_a = shape.modifiers) === null || _a === void 0 ? void 0 : _a.overlayCustomSvg)) {\n    const el = setAttributes(createElement('g'), {\n      cgHash: hash\n    });\n    svgs.push({\n      el\n    });\n    if (from[0] !== to[0] || from[1] !== to[1]) el.appendChild(renderArrow(shape, brush, from, to, current, isShort(shape.dest, dests)));else el.appendChild(renderCircle(brushes[shape.brush], from, current, bounds));\n    if (shape.label) svgs.push({\n      el: renderLabel(shape.label.text, brush.color, hash, from, to, slots),\n      isCustom: true\n    });\n  }\n  if (shape.customSvg) {\n    const on = (_c = (_b = shape.modifiers) === null || _b === void 0 ? void 0 : _b.overlayCustomSvg) !== null && _c !== void 0 ? _c : 'orig';\n    const [x, y] = on === 'label' ? labelCoords(from, to, slots) : on === 'dest' ? to : from;\n    const el = setAttributes(createElement('g'), {\n      transform: `translate(${x},${y})`,\n      cgHash: hash\n    });\n    el.innerHTML = `<svg width=\"1\" height=\"1\" viewBox=\"0 0 100 100\">${shape.customSvg}</svg>`;\n    svgs.push({\n      el,\n      isCustom: true\n    });\n  }\n  return svgs;\n}\nfunction renderCircle(brush, at, current, bounds) {\n  const widths = circleWidth(),\n    radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n  return setAttributes(createElement('circle'), {\n    stroke: brush.color,\n    'stroke-width': widths[current ? 0 : 1],\n    fill: 'none',\n    opacity: opacity(brush, current),\n    cx: at[0],\n    cy: at[1],\n    r: radius - widths[1] / 2\n  });\n}\nfunction renderArrow(s, brush, from, to, current, shorten) {\n  var _a;\n  function renderLine(isHilite) {\n    var _a;\n    const m = arrowMargin(shorten && !current),\n      dx = to[0] - from[0],\n      dy = to[1] - from[1],\n      angle = Math.atan2(dy, dx),\n      xo = Math.cos(angle) * m,\n      yo = Math.sin(angle) * m;\n    return setAttributes(createElement('line'), {\n      stroke: isHilite ? 'white' : brush.color,\n      'stroke-width': lineWidth(brush, current) + (isHilite ? 0.04 : 0),\n      'stroke-linecap': 'round',\n      'marker-end': `url(#arrowhead-${isHilite ? 'hilite' : brush.key})`,\n      opacity: ((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite) ? 1 : opacity(brush, current),\n      x1: from[0],\n      y1: from[1],\n      x2: to[0] - xo,\n      y2: to[1] - yo\n    });\n  }\n  if (!((_a = s.modifiers) === null || _a === void 0 ? void 0 : _a.hilite)) return renderLine(false);\n  const g = createElement('g');\n  const blurred = setAttributes(createElement('g'), {\n    filter: 'url(#cg-filter-blur)'\n  });\n  blurred.appendChild(filterBox(from, to));\n  blurred.appendChild(renderLine(true));\n  g.appendChild(blurred);\n  g.appendChild(renderLine(false));\n  return g;\n}\nfunction renderMarker(brush) {\n  const marker = setAttributes(createElement('marker'), {\n    id: 'arrowhead-' + brush.key,\n    orient: 'auto',\n    overflow: 'visible',\n    markerWidth: 4,\n    markerHeight: 4,\n    refX: brush.key === 'hilite' ? 1.86 : 2.05,\n    refY: 2\n  });\n  marker.appendChild(setAttributes(createElement('path'), {\n    d: 'M0,0 V4 L3,2 Z',\n    fill: brush.color\n  }));\n  marker.setAttribute('cgKey', brush.key);\n  return marker;\n}\nfunction renderLabel(text, color, hash, from, to, slots) {\n  const labelSize = 0.4;\n  const fontSize = labelSize * 0.8 ** text.length;\n  const [x, y] = labelCoords(from, to, slots);\n  const g = setAttributes(createElement('g'), {\n    transform: `translate(${x + 0.5},${y + 0.5})`,\n    cgHash: hash\n  });\n  g.appendChild(setAttributes(createElement('circle'), {\n    r: labelSize / 2,\n    'fill-opacity': 0.8,\n    'stroke-opacity': 0.7,\n    'stroke-width': 0.03,\n    fill: color,\n    stroke: 'white'\n  }));\n  const label = setAttributes(createElement('text'), {\n    'font-size': fontSize,\n    'font-family': 'Noto Sans',\n    'text-anchor': 'middle',\n    fill: 'white',\n    y: fontSize * 0.34,\n    innerHTML: text\n  });\n  label.innerHTML = text;\n  g.appendChild(label);\n  return g;\n}\nfunction orient(pos, color) {\n  return color === 'white' ? pos : [7 - pos[0], 7 - pos[1]];\n}\nfunction isShort(dest, dests) {\n  return true === (dest && dests.has(dest) && dests.get(dest).size > 1);\n}\nfunction createElement(tagName) {\n  return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\nfunction setAttributes(el, attrs) {\n  for (const key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) el.setAttribute(key, attrs[key]);\n  }\n  return el;\n}\nfunction makeCustomBrush(base, modifiers) {\n  return !modifiers ? base : {\n    color: base.color,\n    opacity: Math.round(base.opacity * 10) / 10,\n    lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n    key: [base.key, modifiers.lineWidth].filter(x => x).join('')\n  };\n}\nfunction circleWidth() {\n  return [3 / 64, 4 / 64];\n}\nfunction lineWidth(brush, current) {\n  return (brush.lineWidth || 10) * (current ? 0.85 : 1) / 64;\n}\nfunction opacity(brush, current) {\n  return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\nfunction arrowMargin(shorten) {\n  return (shorten ? 20 : 10) / 64;\n}\nfunction pos2user(pos, bounds) {\n  const xScale = Math.min(1, bounds.width / bounds.height);\n  const yScale = Math.min(1, bounds.height / bounds.width);\n  return [(pos[0] - 3.5) * xScale, (3.5 - pos[1]) * yScale];\n}\nfunction filterBox(from, to) {\n  // lines/arrows are considered to be one dimensional for the purposes of SVG filters,\n  // so we add a transparent bounding box to ensure they apply to the 2nd dimension\n  const box = {\n    from: [Math.floor(Math.min(from[0], to[0])), Math.floor(Math.min(from[1], to[1]))],\n    to: [Math.ceil(Math.max(from[0], to[0])), Math.ceil(Math.max(from[1], to[1]))]\n  };\n  return setAttributes(createElement('rect'), {\n    x: box.from[0],\n    y: box.from[1],\n    width: box.to[0] - box.from[0],\n    height: box.to[1] - box.from[1],\n    fill: 'none',\n    stroke: 'none'\n  });\n}\nfunction moveAngle(from, to, asSlot = true) {\n  const angle = Math.atan2(to[1] - from[1], to[0] - from[0]) + Math.PI;\n  return asSlot ? (Math.round(angle * 8 / Math.PI) + 16) % 16 : angle;\n}\nfunction dist(from, to) {\n  return Math.sqrt([from[0] - to[0], from[1] - to[1]].reduce((acc, x) => acc + x * x, 0));\n}\n/*\n try to place label at the junction of the destination shaft and arrowhead. if there's more than\n 1 arrow pointing to a square, the arrow shortens by 10 / 64 units so the label must move as well.\n \n if the angle between two incoming arrows is pi / 8, such as when an adjacent knight and bishop\n attack the same square, the knight's label is slid further down the shaft by an amount equal to\n our label size to avoid collision\n*/\nfunction labelCoords(from, to, slots) {\n  let mag = dist(from, to);\n  if (mag === 0) return [0.5 + from[0], 0.5 + from[1]];\n  const angle = moveAngle(from, to, false);\n  if (slots) {\n    mag -= 33 / 64; // reduce by arrowhead length\n    if (slots.size > 1) {\n      mag -= 10 / 64; // reduce by shortening factor\n      const slot = moveAngle(from, to);\n      if (slots.has((slot + 1) % 16) || slots.has((slot + 15) % 16)) {\n        if (slot & 1) mag -= 0.4;\n        // and by label size for the knight if another arrow is within pi / 8.\n      }\n    }\n  }\n  return [from[0] - Math.cos(angle) * mag, from[1] - Math.sin(angle) * mag];\n}","map":{"version":3,"names":["key2pos","createElement","setAttributes","createDefs","defs","filter","id","appendChild","stdDeviation","renderSvg","state","shapesEl","customsEl","d","drawable","curD","current","cur","mouseSq","undefined","dests","Map","bounds","dom","nonPieceAutoShapes","autoShapes","autoShape","piece","s","shapes","concat","dest","sources","_a","get","Set","from","pos2user","orient","orig","orientation","to","add","moveAngle","set","map","shape","hash","shapeHash","isShort","push","fullHash","sc","join","prevSvgHash","defsEl","querySelector","syncDefs","syncShapes","renderShape","brushes","brush","makeCustomBrush","modifiers","hilite","key","keysInDom","el","firstElementChild","getAttribute","nextElementSibling","entries","has","renderMarker","syncables","customs","hashesInDom","root","toRemove","elHash","removeChild","svg","isCustom","customSvg","label","shorten","width","height","pieceHash","modifiersHash","textHash","text","x","color","role","scale","m","lineWidth","overlayCustomSvg","h","i","length","charCodeAt","toString","slots","svgs","cgHash","renderArrow","renderCircle","renderLabel","on","_c","_b","y","labelCoords","transform","innerHTML","at","widths","circleWidth","radius","Math","max","stroke","fill","opacity","cx","cy","r","renderLine","isHilite","arrowMargin","dx","dy","angle","atan2","xo","cos","yo","sin","x1","y1","x2","y2","g","blurred","filterBox","marker","overflow","markerWidth","markerHeight","refX","refY","setAttribute","labelSize","fontSize","pos","size","tagName","document","createElementNS","attrs","Object","prototype","hasOwnProperty","call","base","round","xScale","min","yScale","box","floor","ceil","asSlot","PI","dist","sqrt","reduce","acc","mag","slot"],"sources":["C:\\Users\\Bahamut\\Desktop\\Projects\\chess-app\\node_modules\\chessground\\src\\svg.ts"],"sourcesContent":["import { State } from './state.js';\nimport { key2pos } from './util.js';\nimport { Drawable, DrawShape, DrawShapePiece, DrawBrush, DrawBrushes, DrawModifiers } from './draw.js';\nimport { SyncableShape, Hash } from './sync.js';\nimport * as cg from './types.js';\n\ntype CustomBrushes = Map<string, DrawBrush>; // by hash\ntype Svg = { el: SVGElement; isCustom?: boolean };\ntype AngleSlots = Set<number>; // arrow angle slots for label positioning\ntype ArrowDests = Map<cg.Key | undefined, AngleSlots>; // angle slots per dest\n\nexport { createElement, setAttributes };\n\nexport function createDefs(): Element {\n  const defs = createElement('defs');\n  const filter = setAttributes(createElement('filter'), { id: 'cg-filter-blur' });\n  filter.appendChild(setAttributes(createElement('feGaussianBlur'), { stdDeviation: '0.022' }));\n  defs.appendChild(filter);\n  return defs;\n}\n\nexport function renderSvg(state: State, shapesEl: SVGElement, customsEl: SVGElement): void {\n  const d = state.drawable,\n    curD = d.current,\n    cur = curD && curD.mouseSq ? (curD as DrawShape) : undefined,\n    dests: ArrowDests = new Map(),\n    bounds = state.dom.bounds(),\n    nonPieceAutoShapes = d.autoShapes.filter(autoShape => !autoShape.piece);\n\n  for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [cur] : [])) {\n    if (!s.dest) continue;\n    const sources = dests.get(s.dest) ?? new Set(),\n      from = pos2user(orient(key2pos(s.orig), state.orientation), bounds),\n      to = pos2user(orient(key2pos(s.dest), state.orientation), bounds);\n    sources.add(moveAngle(from, to));\n    dests.set(s.dest, sources);\n  }\n  const shapes: SyncableShape[] = d.shapes.concat(nonPieceAutoShapes).map((s: DrawShape) => {\n    return {\n      shape: s,\n      current: false,\n      hash: shapeHash(s, isShort(s.dest, dests), false, bounds),\n    };\n  });\n  if (cur)\n    shapes.push({\n      shape: cur,\n      current: true,\n      hash: shapeHash(cur, isShort(cur.dest, dests), true, bounds),\n    });\n\n  const fullHash = shapes.map(sc => sc.hash).join(';');\n  if (fullHash === state.drawable.prevSvgHash) return;\n  state.drawable.prevSvgHash = fullHash;\n\n  /*\n    -- DOM hierarchy --\n    <svg class=\"cg-shapes\">      (<= svg)\n      <defs>\n        ...(for brushes)...\n      </defs>\n      <g>\n        ...(for arrows and circles)...\n      </g>\n    </svg>\n    <svg class=\"cg-custom-svgs\"> (<= customSvg)\n      <g>\n        ...(for custom svgs)...\n      </g>\n    </svg>\n  */\n\n  const defsEl = shapesEl.querySelector('defs') as SVGElement;\n\n  syncDefs(d, shapes, defsEl);\n  syncShapes(shapes, shapesEl.querySelector('g')!, customsEl.querySelector('g')!, s =>\n    renderShape(state, s, d.brushes, dests, bounds),\n  );\n}\n\n// append only. Don't try to update/remove.\nfunction syncDefs(d: Drawable, shapes: SyncableShape[], defsEl: SVGElement) {\n  const brushes: CustomBrushes = new Map();\n  let brush: DrawBrush;\n  for (const s of shapes) {\n    if (s.shape.dest) {\n      brush = makeCustomBrush(d.brushes[s.shape.brush], s.shape.modifiers);\n      if (s.shape.modifiers?.hilite) brushes.set('hilite', d.brushes['hilite']);\n      brushes.set(brush.key, brush);\n    }\n  }\n  const keysInDom = new Set();\n  let el: SVGElement | undefined = defsEl.firstElementChild as SVGElement;\n  while (el) {\n    keysInDom.add(el.getAttribute('cgKey'));\n    el = el.nextElementSibling as SVGElement | undefined;\n  }\n  for (const [key, brush] of brushes.entries()) {\n    if (!keysInDom.has(key)) defsEl.appendChild(renderMarker(brush));\n  }\n}\n\nfunction syncShapes(\n  syncables: SyncableShape[],\n  shapes: Element,\n  customs: Element,\n  renderShape: (shape: SyncableShape) => Svg[],\n): void {\n  const hashesInDom = new Map();\n\n  for (const sc of syncables) hashesInDom.set(sc.hash, false);\n  for (const root of [shapes, customs]) {\n    const toRemove: SVGElement[] = [];\n    let el: SVGElement | undefined = root.firstElementChild as SVGElement,\n      elHash: Hash | null;\n    while (el) {\n      elHash = el.getAttribute('cgHash') as Hash;\n      if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n      else toRemove.push(el);\n      el = el.nextElementSibling as SVGElement | undefined;\n    }\n    for (const el of toRemove) root.removeChild(el);\n  }\n  // insert shapes that are not yet in dom\n  for (const sc of syncables.filter(s => !hashesInDom.get(s.hash))) {\n    for (const svg of renderShape(sc)) {\n      if (svg.isCustom) customs.appendChild(svg.el);\n      else shapes.appendChild(svg.el);\n    }\n  }\n}\n\nfunction shapeHash(\n  { orig, dest, brush, piece, modifiers, customSvg, label }: DrawShape,\n  shorten: boolean,\n  current: boolean,\n  bounds: DOMRectReadOnly,\n): Hash {\n  // a shape and an overlay svg share a lifetime and have the same cgHash attribute\n  return [\n    bounds.width,\n    bounds.height,\n    current,\n    orig,\n    dest,\n    brush,\n    shorten && '-',\n    piece && pieceHash(piece),\n    modifiers && modifiersHash(modifiers),\n    customSvg && `custom-${textHash(customSvg)}`,\n    label && `label-${textHash(label.text)}`,\n  ]\n    .filter(x => x)\n    .join(',');\n}\n\nfunction pieceHash(piece: DrawShapePiece): Hash {\n  return [piece.color, piece.role, piece.scale].filter(x => x).join(',');\n}\n\nfunction modifiersHash(m: DrawModifiers): Hash {\n  return [m.lineWidth, m.hilite && '*', m.overlayCustomSvg?.[0]].filter(x => x).join(',');\n}\n\nfunction textHash(s: string): Hash {\n  // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n  let h = 0;\n  for (let i = 0; i < s.length; i++) {\n    h = ((h << 5) - h + s.charCodeAt(i)) >>> 0;\n  }\n  return h.toString();\n}\n\nfunction renderShape(\n  state: State,\n  { shape, current, hash }: SyncableShape,\n  brushes: DrawBrushes,\n  dests: ArrowDests,\n  bounds: DOMRectReadOnly,\n): Svg[] {\n  const from = pos2user(orient(key2pos(shape.orig), state.orientation), bounds),\n    to = shape.dest ? pos2user(orient(key2pos(shape.dest), state.orientation), bounds) : from,\n    brush = makeCustomBrush(brushes[shape.brush], shape.modifiers),\n    slots = dests.get(shape.dest),\n    svgs: Svg[] = [];\n\n  if (!shape.customSvg || shape.modifiers?.overlayCustomSvg) {\n    const el = setAttributes(createElement('g'), { cgHash: hash });\n    svgs.push({ el });\n\n    if (from[0] !== to[0] || from[1] !== to[1])\n      el.appendChild(renderArrow(shape, brush, from, to, current, isShort(shape.dest, dests)));\n    else el.appendChild(renderCircle(brushes[shape.brush], from, current, bounds));\n\n    if (shape.label)\n      svgs.push({ el: renderLabel(shape.label.text, brush.color, hash, from, to, slots), isCustom: true });\n  }\n  if (shape.customSvg) {\n    const on = shape.modifiers?.overlayCustomSvg ?? 'orig';\n    const [x, y] = on === 'label' ? labelCoords(from, to, slots) : on === 'dest' ? to : from;\n    const el = setAttributes(createElement('g'), { transform: `translate(${x},${y})`, cgHash: hash });\n    el.innerHTML = `<svg width=\"1\" height=\"1\" viewBox=\"0 0 100 100\">${shape.customSvg}</svg>`;\n    svgs.push({ el, isCustom: true });\n  }\n  return svgs;\n}\n\nfunction renderCircle(brush: DrawBrush, at: cg.NumberPair, current: boolean, bounds: DOMRectReadOnly): SVGElement {\n  const widths = circleWidth(),\n    radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n  return setAttributes(createElement('circle'), {\n    stroke: brush.color,\n    'stroke-width': widths[current ? 0 : 1],\n    fill: 'none',\n    opacity: opacity(brush, current),\n    cx: at[0],\n    cy: at[1],\n    r: radius - widths[1] / 2,\n  });\n}\n\nfunction renderArrow(\n  s: DrawShape,\n  brush: DrawBrush,\n  from: cg.NumberPair,\n  to: cg.NumberPair,\n  current: boolean,\n  shorten: boolean,\n): SVGElement {\n  function renderLine(isHilite: boolean) {\n    const m = arrowMargin(shorten && !current),\n      dx = to[0] - from[0],\n      dy = to[1] - from[1],\n      angle = Math.atan2(dy, dx),\n      xo = Math.cos(angle) * m,\n      yo = Math.sin(angle) * m;\n    return setAttributes(createElement('line'), {\n      stroke: isHilite ? 'white' : brush.color,\n      'stroke-width': lineWidth(brush, current) + (isHilite ? 0.04 : 0),\n      'stroke-linecap': 'round',\n      'marker-end': `url(#arrowhead-${isHilite ? 'hilite' : brush.key})`,\n      opacity: s.modifiers?.hilite ? 1 : opacity(brush, current),\n      x1: from[0],\n      y1: from[1],\n      x2: to[0] - xo,\n      y2: to[1] - yo,\n    });\n  }\n  if (!s.modifiers?.hilite) return renderLine(false);\n\n  const g = createElement('g');\n  const blurred = setAttributes(createElement('g'), { filter: 'url(#cg-filter-blur)' });\n  blurred.appendChild(filterBox(from, to));\n  blurred.appendChild(renderLine(true));\n  g.appendChild(blurred);\n  g.appendChild(renderLine(false));\n  return g;\n}\n\nfunction renderMarker(brush: DrawBrush): SVGElement {\n  const marker = setAttributes(createElement('marker'), {\n    id: 'arrowhead-' + brush.key,\n    orient: 'auto',\n    overflow: 'visible',\n    markerWidth: 4,\n    markerHeight: 4,\n    refX: brush.key === 'hilite' ? 1.86 : 2.05,\n    refY: 2,\n  });\n  marker.appendChild(\n    setAttributes(createElement('path'), {\n      d: 'M0,0 V4 L3,2 Z',\n      fill: brush.color,\n    }),\n  );\n  marker.setAttribute('cgKey', brush.key);\n  return marker;\n}\n\nfunction renderLabel(\n  text: string,\n  color: string,\n  hash: string,\n  from: cg.NumberPair,\n  to: cg.NumberPair,\n  slots?: AngleSlots,\n): SVGElement {\n  const labelSize = 0.4;\n  const fontSize = labelSize * 0.8 ** text.length;\n  const [x, y] = labelCoords(from, to, slots);\n  const g = setAttributes(createElement('g'), {\n    transform: `translate(${x + 0.5},${y + 0.5})`,\n    cgHash: hash,\n  });\n  g.appendChild(\n    setAttributes(createElement('circle'), {\n      r: labelSize / 2,\n      'fill-opacity': 0.8,\n      'stroke-opacity': 0.7,\n      'stroke-width': 0.03,\n      fill: color,\n      stroke: 'white',\n    }),\n  );\n  const label = setAttributes(createElement('text'), {\n    'font-size': fontSize,\n    'font-family': 'Noto Sans',\n    'text-anchor': 'middle',\n    fill: 'white',\n    y: fontSize * 0.34,\n    innerHTML: text,\n  });\n  label.innerHTML = text;\n  g.appendChild(label);\n  return g;\n}\n\nfunction orient(pos: cg.Pos, color: cg.Color): cg.Pos {\n  return color === 'white' ? pos : [7 - pos[0], 7 - pos[1]];\n}\n\nfunction isShort(dest: cg.Key | undefined, dests: ArrowDests) {\n  return true === (dest && dests.has(dest) && dests.get(dest)!.size > 1);\n}\n\nfunction createElement(tagName: string): SVGElement {\n  return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\n\nfunction setAttributes(el: SVGElement, attrs: { [key: string]: any }): SVGElement {\n  for (const key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) el.setAttribute(key, attrs[key]);\n  }\n  return el;\n}\n\nfunction makeCustomBrush(base: DrawBrush, modifiers: DrawModifiers | undefined): DrawBrush {\n  return !modifiers\n    ? base\n    : {\n        color: base.color,\n        opacity: Math.round(base.opacity * 10) / 10,\n        lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n        key: [base.key, modifiers.lineWidth].filter(x => x).join(''),\n      };\n}\n\nfunction circleWidth(): [number, number] {\n  return [3 / 64, 4 / 64];\n}\n\nfunction lineWidth(brush: DrawBrush, current: boolean): number {\n  return ((brush.lineWidth || 10) * (current ? 0.85 : 1)) / 64;\n}\n\nfunction opacity(brush: DrawBrush, current: boolean): number {\n  return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\n\nfunction arrowMargin(shorten: boolean): number {\n  return (shorten ? 20 : 10) / 64;\n}\n\nfunction pos2user(pos: cg.Pos, bounds: DOMRectReadOnly): cg.NumberPair {\n  const xScale = Math.min(1, bounds.width / bounds.height);\n  const yScale = Math.min(1, bounds.height / bounds.width);\n  return [(pos[0] - 3.5) * xScale, (3.5 - pos[1]) * yScale];\n}\n\nfunction filterBox(from: cg.NumberPair, to: cg.NumberPair): SVGElement {\n  // lines/arrows are considered to be one dimensional for the purposes of SVG filters,\n  // so we add a transparent bounding box to ensure they apply to the 2nd dimension\n  const box = {\n    from: [Math.floor(Math.min(from[0], to[0])), Math.floor(Math.min(from[1], to[1]))],\n    to: [Math.ceil(Math.max(from[0], to[0])), Math.ceil(Math.max(from[1], to[1]))],\n  };\n  return setAttributes(createElement('rect'), {\n    x: box.from[0],\n    y: box.from[1],\n    width: box.to[0] - box.from[0],\n    height: box.to[1] - box.from[1],\n    fill: 'none',\n    stroke: 'none',\n  });\n}\n\nfunction moveAngle(from: cg.NumberPair, to: cg.NumberPair, asSlot = true) {\n  const angle = Math.atan2(to[1] - from[1], to[0] - from[0]) + Math.PI;\n  return asSlot ? (Math.round((angle * 8) / Math.PI) + 16) % 16 : angle;\n}\n\nfunction dist(from: cg.NumberPair, to: cg.NumberPair): number {\n  return Math.sqrt([from[0] - to[0], from[1] - to[1]].reduce((acc, x) => acc + x * x, 0));\n}\n\n/*\n try to place label at the junction of the destination shaft and arrowhead. if there's more than\n 1 arrow pointing to a square, the arrow shortens by 10 / 64 units so the label must move as well. \n \n if the angle between two incoming arrows is pi / 8, such as when an adjacent knight and bishop\n attack the same square, the knight's label is slid further down the shaft by an amount equal to\n our label size to avoid collision\n*/\n\nfunction labelCoords(from: cg.NumberPair, to: cg.NumberPair, slots?: AngleSlots): cg.NumberPair {\n  let mag = dist(from, to);\n  if (mag === 0) return [0.5 + from[0], 0.5 + from[1]];\n  const angle = moveAngle(from, to, false);\n  if (slots) {\n    mag -= 33 / 64; // reduce by arrowhead length\n    if (slots.size > 1) {\n      mag -= 10 / 64; // reduce by shortening factor\n      const slot = moveAngle(from, to);\n      if (slots.has((slot + 1) % 16) || slots.has((slot + 15) % 16)) {\n        if (slot & 1) mag -= 0.4;\n        // and by label size for the knight if another arrow is within pi / 8.\n      }\n    }\n  }\n  return [from[0] - Math.cos(angle) * mag, from[1] - Math.sin(angle) * mag];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}