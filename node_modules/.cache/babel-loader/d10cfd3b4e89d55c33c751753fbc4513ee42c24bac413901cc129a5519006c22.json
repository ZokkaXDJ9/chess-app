{"ast":null,"code":"import * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport { anim } from './anim.js';\nexport function start(s, e) {\n  if (!(s.trustAllEvents || e.isTrusted)) return; // only trust when trustAllEvents is enabled\n  if (e.button !== undefined && e.button !== 0) return; // only touch or left click\n  if (e.touches && e.touches.length > 1) return; // support one finger touch only\n  const bounds = s.dom.bounds(),\n    position = util.eventPosition(e),\n    orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n  if (!orig) return;\n  const piece = s.pieces.get(orig);\n  const previouslySelected = s.selected;\n  if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor)) drawClear(s);\n  // Prevent touch scroll and create no corresponding mouse event, if there\n  // is an intent to interact with the board.\n  if (e.cancelable !== false && (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position))) e.preventDefault();else if (e.touches) return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n  const hadPremove = !!s.premovable.current;\n  const hadPredrop = !!s.predroppable.current;\n  s.stats.ctrlKey = e.ctrlKey;\n  if (s.selected && board.canMove(s, s.selected, orig)) {\n    anim(state => board.selectSquare(state, orig), s);\n  } else {\n    board.selectSquare(s, orig);\n  }\n  const stillSelected = s.selected === orig;\n  const element = pieceElementByKey(s, orig);\n  if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n    s.draggable.current = {\n      orig,\n      piece,\n      origPos: position,\n      pos: position,\n      started: s.draggable.autoDistance && s.stats.dragged,\n      element,\n      previouslySelected,\n      originTarget: e.target,\n      keyHasChanged: false\n    };\n    element.cgDragging = true;\n    element.classList.add('dragging');\n    // place ghost\n    const ghost = s.dom.elements.ghost;\n    if (ghost) {\n      ghost.className = `ghost ${piece.color} ${piece.role}`;\n      util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n      util.setVisible(ghost, true);\n    }\n    processDrag(s);\n  } else {\n    if (hadPremove) board.unsetPremove(s);\n    if (hadPredrop) board.unsetPredrop(s);\n  }\n  s.dom.redraw();\n}\nfunction pieceCloseTo(s, pos) {\n  const asWhite = board.whitePov(s),\n    bounds = s.dom.bounds(),\n    radiusSq = Math.pow(bounds.width / 8, 2);\n  for (const key of s.pieces.keys()) {\n    const center = util.computeSquareCenter(key, asWhite, bounds);\n    if (util.distanceSq(center, pos) <= radiusSq) return true;\n  }\n  return false;\n}\nexport function dragNewPiece(s, piece, e, force) {\n  const key = 'a0';\n  s.pieces.set(key, piece);\n  s.dom.redraw();\n  const position = util.eventPosition(e);\n  s.draggable.current = {\n    orig: key,\n    piece,\n    origPos: position,\n    pos: position,\n    started: true,\n    element: () => pieceElementByKey(s, key),\n    originTarget: e.target,\n    newPiece: true,\n    force: !!force,\n    keyHasChanged: false\n  };\n  processDrag(s);\n}\nfunction processDrag(s) {\n  requestAnimationFrame(() => {\n    var _a;\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // cancel animations while dragging\n    if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig)) s.animation.current = undefined;\n    // if moving piece is gone, cancel\n    const origPiece = s.pieces.get(cur.orig);\n    if (!origPiece || !util.samePiece(origPiece, cur.piece)) cancel(s);else {\n      if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2)) cur.started = true;\n      if (cur.started) {\n        // support lazy elements\n        if (typeof cur.element === 'function') {\n          const found = cur.element();\n          if (!found) return;\n          found.cgDragging = true;\n          found.classList.add('dragging');\n          cur.element = found;\n        }\n        const bounds = s.dom.bounds();\n        util.translate(cur.element, [cur.pos[0] - bounds.left - bounds.width / 16, cur.pos[1] - bounds.top - bounds.height / 16]);\n        cur.keyHasChanged || (cur.keyHasChanged = cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds));\n      }\n    }\n    processDrag(s);\n  });\n}\nexport function move(s, e) {\n  // support one finger touch only\n  if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n    s.draggable.current.pos = util.eventPosition(e);\n  }\n}\nexport function end(s, e) {\n  const cur = s.draggable.current;\n  if (!cur) return;\n  // create no corresponding mouse event\n  if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n  // comparing with the origin target is an easy way to test that the end event\n  // has the same touch origin\n  if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n    s.draggable.current = undefined;\n    return;\n  }\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n  // touchend has no position; so use the last touchmove position instead\n  const eventPos = util.eventPosition(e) || cur.pos;\n  const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n  if (dest && cur.started && cur.orig !== dest) {\n    if (cur.newPiece) board.dropNewPiece(s, cur.orig, dest, cur.force);else {\n      s.stats.ctrlKey = e.ctrlKey;\n      if (board.userMove(s, cur.orig, dest)) s.stats.dragged = true;\n    }\n  } else if (cur.newPiece) {\n    s.pieces.delete(cur.orig);\n  } else if (s.draggable.deleteOnDropOff && !dest) {\n    s.pieces.delete(cur.orig);\n    board.callUserFunction(s.events.change);\n  }\n  if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest)) board.unselect(s);else if (!s.selectable.enabled) board.unselect(s);\n  removeDragElements(s);\n  s.draggable.current = undefined;\n  s.dom.redraw();\n}\nexport function cancel(s) {\n  const cur = s.draggable.current;\n  if (cur) {\n    if (cur.newPiece) s.pieces.delete(cur.orig);\n    s.draggable.current = undefined;\n    board.unselect(s);\n    removeDragElements(s);\n    s.dom.redraw();\n  }\n}\nfunction removeDragElements(s) {\n  const e = s.dom.elements;\n  if (e.ghost) util.setVisible(e.ghost, false);\n}\nfunction pieceElementByKey(s, key) {\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if (el.cgKey === key && el.tagName === 'PIECE') return el;\n    el = el.nextSibling;\n  }\n  return;\n}","map":{"version":3,"names":["board","util","clear","drawClear","anim","start","s","e","trustAllEvents","isTrusted","button","undefined","touches","length","bounds","dom","position","eventPosition","orig","getKeyAtDomPos","whitePov","piece","pieces","get","previouslySelected","selected","drawable","enabled","eraseOnClick","color","turnColor","cancelable","blockTouchScroll","pieceCloseTo","preventDefault","hadPremove","premovable","current","hadPredrop","predroppable","stats","ctrlKey","canMove","state","selectSquare","stillSelected","element","pieceElementByKey","isDraggable","draggable","origPos","pos","started","autoDistance","dragged","originTarget","target","keyHasChanged","cgDragging","classList","add","ghost","elements","className","role","translate","posToTranslate","key2pos","setVisible","processDrag","unsetPremove","unsetPredrop","redraw","asWhite","radiusSq","Math","pow","width","key","keys","center","computeSquareCenter","distanceSq","dragNewPiece","force","set","newPiece","requestAnimationFrame","cur","_a","animation","plan","anims","has","origPiece","samePiece","cancel","distance","found","left","top","height","move","end","type","eventPos","dest","dropNewPiece","userMove","delete","deleteOnDropOff","callUserFunction","events","change","unselect","selectable","removeDragElements","el","firstChild","cgKey","tagName","nextSibling"],"sources":["C:\\Users\\Bahamut\\Desktop\\Projects\\chess-app\\node_modules\\chessground\\src\\drag.ts"],"sourcesContent":["import { State } from './state.js';\nimport * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport * as cg from './types.js';\nimport { anim } from './anim.js';\n\nexport interface DragCurrent {\n  orig: cg.Key; // orig key of dragging piece\n  piece: cg.Piece;\n  origPos: cg.NumberPair; // first event position\n  pos: cg.NumberPair; // latest event position\n  started: boolean; // whether the drag has started; as per the distance setting\n  element: cg.PieceNode | (() => cg.PieceNode | undefined);\n  newPiece?: boolean; // it it a new piece from outside the board\n  force?: boolean; // can the new piece replace an existing one (editor)\n  previouslySelected?: cg.Key;\n  originTarget: EventTarget | null;\n  keyHasChanged: boolean; // whether the drag has left the orig key\n}\n\nexport function start(s: State, e: cg.MouchEvent): void {\n  if (!(s.trustAllEvents || e.isTrusted)) return; // only trust when trustAllEvents is enabled\n  if (e.button !== undefined && e.button !== 0) return; // only touch or left click\n  if (e.touches && e.touches.length > 1) return; // support one finger touch only\n  const bounds = s.dom.bounds(),\n    position = util.eventPosition(e)!,\n    orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n  if (!orig) return;\n  const piece = s.pieces.get(orig);\n  const previouslySelected = s.selected;\n  if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor))\n    drawClear(s);\n  // Prevent touch scroll and create no corresponding mouse event, if there\n  // is an intent to interact with the board.\n  if (\n    e.cancelable !== false &&\n    (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position))\n  )\n    e.preventDefault();\n  else if (e.touches) return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n\n  const hadPremove = !!s.premovable.current;\n  const hadPredrop = !!s.predroppable.current;\n  s.stats.ctrlKey = e.ctrlKey;\n  if (s.selected && board.canMove(s, s.selected, orig)) {\n    anim(state => board.selectSquare(state, orig), s);\n  } else {\n    board.selectSquare(s, orig);\n  }\n  const stillSelected = s.selected === orig;\n  const element = pieceElementByKey(s, orig);\n  if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n    s.draggable.current = {\n      orig,\n      piece,\n      origPos: position,\n      pos: position,\n      started: s.draggable.autoDistance && s.stats.dragged,\n      element,\n      previouslySelected,\n      originTarget: e.target,\n      keyHasChanged: false,\n    };\n    element.cgDragging = true;\n    element.classList.add('dragging');\n    // place ghost\n    const ghost = s.dom.elements.ghost;\n    if (ghost) {\n      ghost.className = `ghost ${piece.color} ${piece.role}`;\n      util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n      util.setVisible(ghost, true);\n    }\n    processDrag(s);\n  } else {\n    if (hadPremove) board.unsetPremove(s);\n    if (hadPredrop) board.unsetPredrop(s);\n  }\n  s.dom.redraw();\n}\n\nfunction pieceCloseTo(s: State, pos: cg.NumberPair): boolean {\n  const asWhite = board.whitePov(s),\n    bounds = s.dom.bounds(),\n    radiusSq = Math.pow(bounds.width / 8, 2);\n  for (const key of s.pieces.keys()) {\n    const center = util.computeSquareCenter(key, asWhite, bounds);\n    if (util.distanceSq(center, pos) <= radiusSq) return true;\n  }\n  return false;\n}\n\nexport function dragNewPiece(s: State, piece: cg.Piece, e: cg.MouchEvent, force?: boolean): void {\n  const key: cg.Key = 'a0';\n  s.pieces.set(key, piece);\n  s.dom.redraw();\n\n  const position = util.eventPosition(e)!;\n\n  s.draggable.current = {\n    orig: key,\n    piece,\n    origPos: position,\n    pos: position,\n    started: true,\n    element: () => pieceElementByKey(s, key),\n    originTarget: e.target,\n    newPiece: true,\n    force: !!force,\n    keyHasChanged: false,\n  };\n  processDrag(s);\n}\n\nfunction processDrag(s: State): void {\n  requestAnimationFrame(() => {\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // cancel animations while dragging\n    if (s.animation.current?.plan.anims.has(cur.orig)) s.animation.current = undefined;\n    // if moving piece is gone, cancel\n    const origPiece = s.pieces.get(cur.orig);\n    if (!origPiece || !util.samePiece(origPiece, cur.piece)) cancel(s);\n    else {\n      if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))\n        cur.started = true;\n      if (cur.started) {\n        // support lazy elements\n        if (typeof cur.element === 'function') {\n          const found = cur.element();\n          if (!found) return;\n          found.cgDragging = true;\n          found.classList.add('dragging');\n          cur.element = found;\n        }\n\n        const bounds = s.dom.bounds();\n        util.translate(cur.element, [\n          cur.pos[0] - bounds.left - bounds.width / 16,\n          cur.pos[1] - bounds.top - bounds.height / 16,\n        ]);\n\n        cur.keyHasChanged ||= cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds);\n      }\n    }\n    processDrag(s);\n  });\n}\n\nexport function move(s: State, e: cg.MouchEvent): void {\n  // support one finger touch only\n  if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n    s.draggable.current.pos = util.eventPosition(e)!;\n  }\n}\n\nexport function end(s: State, e: cg.MouchEvent): void {\n  const cur = s.draggable.current;\n  if (!cur) return;\n  // create no corresponding mouse event\n  if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n  // comparing with the origin target is an easy way to test that the end event\n  // has the same touch origin\n  if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n    s.draggable.current = undefined;\n    return;\n  }\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n  // touchend has no position; so use the last touchmove position instead\n  const eventPos = util.eventPosition(e) || cur.pos;\n  const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n  if (dest && cur.started && cur.orig !== dest) {\n    if (cur.newPiece) board.dropNewPiece(s, cur.orig, dest, cur.force);\n    else {\n      s.stats.ctrlKey = e.ctrlKey;\n      if (board.userMove(s, cur.orig, dest)) s.stats.dragged = true;\n    }\n  } else if (cur.newPiece) {\n    s.pieces.delete(cur.orig);\n  } else if (s.draggable.deleteOnDropOff && !dest) {\n    s.pieces.delete(cur.orig);\n    board.callUserFunction(s.events.change);\n  }\n  if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest)) board.unselect(s);\n  else if (!s.selectable.enabled) board.unselect(s);\n\n  removeDragElements(s);\n\n  s.draggable.current = undefined;\n  s.dom.redraw();\n}\n\nexport function cancel(s: State): void {\n  const cur = s.draggable.current;\n  if (cur) {\n    if (cur.newPiece) s.pieces.delete(cur.orig);\n    s.draggable.current = undefined;\n    board.unselect(s);\n    removeDragElements(s);\n    s.dom.redraw();\n  }\n}\n\nfunction removeDragElements(s: State): void {\n  const e = s.dom.elements;\n  if (e.ghost) util.setVisible(e.ghost, false);\n}\n\nfunction pieceElementByKey(s: State, key: cg.Key): cg.PieceNode | undefined {\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if ((el as cg.KeyedNode).cgKey === key && (el as cg.KeyedNode).tagName === 'PIECE') return el as cg.PieceNode;\n    el = el.nextSibling;\n  }\n  return;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}